<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quant Engine</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React y ReactDOM CDN -->
  <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.development.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel para JSX -->
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
  <!-- Chart.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Fuente Roboto -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@500;600;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Roboto', sans-serif;
      background: linear-gradient(135deg, #111827 0%, #1e293b 100%);
      background-attachment: fixed;
    }
    .logo-text {
      background: linear-gradient(90deg, #3b82f6 0%, #60a5fa 100%);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }
    .button-gradient {
      background: linear-gradient(90deg, #3b82f6 0%, #1e40af 100%);
    }
    .fade-in {
      animation: fadeIn 0.3s ease-in;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }
  </style>
</head>
<body class="min-h-screen flex flex-col">
  <div id="root"></div>
  <script type="text/babel">
    // Componente Logo
    function Logo() {
      return (
        <div className="text-center">
          <h1 className="text-3xl font-semibold tracking-wide logo-text">Quant Engine</h1>
        </div>
      );
    }

    // Componente SearchBar
    function SearchBar() {
      const [ticker, setTicker] = React.useState('');
      const [startDate, setStartDate] = React.useState('2020-01-01');
      const [endDate, setEndDate] = React.useState(new Date().toISOString().split('T')[0]);
      const [suggestions, setSuggestions] = React.useState([]);
      const [results, setResults] = React.useState(null);
      const [error, setError] = React.useState(null);
      const [placeholder, setPlaceholder] = React.useState('');
      const [selectedStrategy, setSelectedStrategy] = React.useState(null);
      const tickers = ['AAPL', 'MSFT', 'GOOGL', 'TSLA', 'XOM', 'JPM'];
      const chartRef = React.useRef(null);

      // Animación de escritura para el placeholder (rápida)
      React.useEffect(() => {
        let currentTickerIndex = 0;
        let charIndex = 0;
        let isTyping = true;
        let timeout;

        const updatePlaceholder = () => {
          const currentTicker = tickers[currentTickerIndex];
          if (isTyping) {
            setPlaceholder(currentTicker.slice(0, charIndex + 1));
            charIndex++;
            if (charIndex === currentTicker.length) {
              isTyping = false;
              timeout = setTimeout(() => {
                charIndex--;
                updatePlaceholder();
              }, 500);
            } else {
              timeout = setTimeout(updatePlaceholder, 200);
            }
          } else {
            setPlaceholder(currentTicker.slice(0, charIndex));
            charIndex--;
            if (charIndex < 0) {
              isTyping = true;
              charIndex = 0;
              currentTickerIndex = (currentTickerIndex + 1) % tickers.length;
              timeout = setTimeout(updatePlaceholder, 300);
            } else {
              timeout = setTimeout(updatePlaceholder, 100);
            }
          }
        };

        updatePlaceholder();
        return () => clearTimeout(timeout);
      }, []);

      // Manejar sugerencias
      React.useEffect(() => {
        if (ticker.length > 0) {
          const filtered = tickers.filter(t => t.toLowerCase().startsWith(ticker.toLowerCase()));
          setSuggestions(filtered);
        } else {
          setSuggestions([]);
        }
      }, [ticker]);

      // Manejar entrada del usuario
      const handleInputChange = (e) => {
        setTicker(e.target.value.toUpperCase());
        setError(null);
      };

      // Seleccionar ticker del dropdown
      const handleSelectTicker = (selectedTicker) => {
        setTicker(selectedTicker);
        setSuggestions([]);
      };

      // Manejar acción del botón Backtest Strategies
      const handleAnalyze = async () => {
        if (!ticker.trim()) {
          setError('Por favor, ingrese un ticker.');
          return;
        }
        if (!startDate || !endDate) {
          setError('Por favor, seleccione fechas válidas.');
          return;
        }
        try {
          const response = await fetch('https://quant-3-2-new.onrender.com/evaluate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ ticker, start_date: startDate, end_date: endDate })
          });
          const data = await response.json();
          if (data.status === 'error') {
            setError(data.message);
            setResults(null);
          } else {
            setResults(data.results);
            setSelectedStrategy(data.results[0].strategy_name); // Seleccionar primera estrategia por defecto
          }
        } catch (err) {
          setError('Error al conectar con el servidor.');
          setResults(null);
        }
      };

      // Renderizar gráfico con Chart.js
      React.useEffect(() => {
        if (results && chartRef.current && selectedStrategy) {
          const strategyData = results.find(r => r.strategy_name === selectedStrategy);
          if (strategyData && strategyData.cum_returns) {
            new Chart(chartRef.current, {
              type: 'line',
              data: {
                labels: Array.from({ length: strategyData.cum_returns.length }, (_, i) => i),
                datasets: [{
                  label: `${selectedStrategy} Cumulative Returns`,
                  data: strategyData.cum_returns,
                  borderColor: '#60a5fa',
                  backgroundColor: 'rgba(96, 165, 250, 0.2)',
                  fill: true,
                  tension: 0.4
                }]
              },
              options: {
                responsive: true,
                scales: { y: { beginAtZero: true } },
                plugins: { legend: { labels: { color: '#d1d5db' } } }
              }
            });
          }
        }
      }, [results, selectedStrategy]);

      return (
        <div className="flex-grow flex items-center justify-center px-4">
          <div className="text-center space-y-8">
            <Logo />
            <div className="relative">
              <input
                type="text"
                value={ticker}
                onChange={handleInputChange}
                placeholder={placeholder}
                className="w-full p-3 rounded-xl bg-gray-900 text-white placeholder-gray-400 focus:outline-none focus:ring-1 focus:ring-blue-600 transition-all duration-200 text-base"
              />
              {suggestions.length > 0 && (
                <ul className="absolute w-full bg-gray-900 rounded-xl mt-1 max-h-48 overflow-auto border border-gray-700 z-10 fade-in">
                  {suggestions.map((sug, index) => (
                    <li
                      key={index}
                      onClick={() => handleSelectTicker(sug)}
                      className="p-2 text-white hover:bg-gray-800 cursor-pointer transition-all duration-200 text-xs"
                    >
                      {sug}
                    </li>
                  ))}
                </ul>
              )}
            </div>
            <div className="flex justify-center space-x-2">
              <input
                type="date"
                value={startDate}
                onChange={(e) => setStartDate(e.target.value)}
                className="p-2 rounded-xl bg-gray-800 text-white focus:outline-none focus:ring-1 focus:ring-blue-600 transition-all duration-200 text-xs"
              />
              <input
                type="date"
                value={endDate}
                onChange={(e) => setEndDate(e.target.value)}
                className="p-2 rounded-xl bg-gray-800 text-white focus:outline-none focus:ring-1 focus:ring-blue-600 transition-all duration-200 text-xs"
              />
            </div>
            <button
              onClick={handleAnalyze}
              className="w-full p-3 button-gradient text-white rounded-xl hover:opacity-90 transition-all duration-200 font-semibold text-base"
            >
              Backtest Strategies
            </button>
            {error && <p className="text-red-400 text-xs">{error}</p>}
            {results && (
              <div className="mt-6 space-y-3 max-w-2xl">
                <div className="flex space-x-4">
                  {results.map((result, index) => (
                    <button
                      key={index}
                      onClick={() => setSelectedStrategy(result.strategy_name)}
                      className={`px-3 py-1 rounded-md ${selectedStrategy === result.strategy_name ? 'bg-blue-600' : 'bg-gray-700'} text-white text-xs`}
                    >
                      {result.strategy_name}
                    </button>
                  ))}
                </div>
                <h2 className="text-xl font-semibold text-white">Resultados para {ticker}</h2>
                <canvas ref={chartRef} className="w-full fade-in"></canvas>
                {results.map((result, index) => (
                  selectedStrategy === result.strategy_name && (
                    <div key={index} className="p-4 bg-gray-900 rounded-md border border-gray-700 fade-in">
                      <p className="text-base font-semibold text-white">{result.strategy_name}</p>
                      <p className="text-xs text-gray-300"><strong>Parámetros:</strong> {JSON.stringify(result.params)}</p>
                      <p className="text-xs text-gray-300"><strong>Sharpe:</strong> {result.sharpe.toFixed(2)}</p>
                      <p className="text-xs text-gray-300"><strong>CAGR:</strong> {(result.cagr * 100).toFixed(2)}%</p>
                      <p className="text-xs text-gray-300"><strong>Max Drawdown:</strong> {(result.max_drawdown * 100).toFixed(2)}%</p>
                      <p className="text-xs text-gray-300"><strong>Score:</strong> {result.score.toFixed(2)}</p>
                      <p className="text-xs text-gray-300"><strong>Posición:</strong> {result.position}</p>
                      <p className="text-xs text-gray-300"><strong>Precio Actual:</strong> ${result.current_price.toFixed(2)}</p>
                      <p className="text-xs text-gray-300"><strong>Precio Objetivo:</strong> ${result.price_target.toFixed(2)}</p>
                      <p className="text-xs text-gray-300"><strong>Último Cambio:</strong> {result.last_change_date} ({result.last_change_type})</p>
                    </div>
                  )
                ))}
              </div>
            )}
          </div>
        </div>
      );
    }

    // Componente principal App
    function App() {
      return (
        <div className="relative">
          <SearchBar />
        </div>
      );
    }

    // Renderizar la aplicación
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>